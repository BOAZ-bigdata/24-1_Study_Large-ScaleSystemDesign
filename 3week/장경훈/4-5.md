# 4장 처리율 제한 장치의 설계

네트워크 시스템에서 처리율 제한 장치는 디도스 공격에 의한 자원 고갈을 방지할 수 있다. 또한 제 3자 API에 사용료를 지불하는 기업에게는 비용적으로 효율적이다. 처리율 제한 장치를 구현하기 위해서는 다음과 같은 순서를 지켜 설계해야한다.

<strong>1. 문제 이해 및 설계 범위 확정<br></strong>
<strong>2. 개략적 설계안 제시 및 동의 구하기<br></strong>
<strong>3. 상세 설계<br></strong>
<strong>4. 마무리<br></strong>


## 4-1 문제 이해 및 설계 범위 확정
면접관과 소통을 통해서 제한 장치를 구현함에 있어 분명이 해야한다. 

## 4-2 개략적 설계안 제시 및 동의 구하기 
- 처리율 제한 장치를 상대적으로 클라이언트 측에 두는것보다 서버측에 두는것이 좋다.
- 미들웨어를 사용해서 제한을 둔다면 API Gateway가 이 역할을 할 수 있다. 

## 처리율 제한 알고리즘
### 토큰 버킷
- 주기적으로 버킷안에 토큰이 채워진다. 요청이 처리될 때마다 하나의 토큰을 사용해서 시스템에 요청을 전달하는 방식. 토큰이 없다면 토큰이 채워질때까지 오는 API요청은 삭제된다. <br>

<strong>장점: 구현이 쉽고 메모리 사용 측면에서 효율적이다<br></strong>
<strong>단점: 버킷 크기와 토큰 공급률을 적절하게 튜닝하는게 쉽지 않다.</strong>

### 누출 버킷
- FIFO로 구현하여 큐가 빈자리가 있다면 요청을 추가 그렇지 않다면 버린다.<br>

<strong>장점: 메모리 사용량 측면에서 효율적이며 고정된 처리율 덕분에 안정적이다.</br></strong>
<strong>단점: 단시간에 많은 트레픽이 모이면 최신 요청들이 버려진다. 또한 두개의 인자를 올바르게 튜닝하기 어렵다</strong>

### 고정 윈도 카운터
- 타임라인을 고정된 윈도 간격으로 나누고 각 윈도마다 카운터를 붙혀 임계치에 도달하면 새로운 요청은 윈도가 열릴 때 까지 대기하는 방식.<br>

<strong>장점: 메모리 효율이 좋으며 특정 트래픽 패턴을 처리하기 용이<br></strong>
<strong>단점: 윈도 경계에 일시적으로 많은 트래픽이 몰리면 처리 한도보다 많은 양의 요청을 처리해야함</strong>

### 이동 윈도 로깅 알고리즘
- 타임스탬프 데이터를 레디스의 정렬집합 같은 캐시에 보관 새요청이 오면 만료된 타임스템프는 제거. 로그의 크기가 허용치보다 같거나 작으면 시스템에 전달 그렇지 않으면 처리 거부 <br>

<strong>장점: 매커니즘이 정교해서 처리율 한도를 넘지 않는다.<br></strong>
<strong>단점: 거부된 타임스탬프를 보관하기 때문에 다량의 메모리 사용</strong>
### 이동 윈도 카운터
- 고정 윈도 카운터 + 이동 윈도 로깅<br>

<strong>장점: 이전시간대의 평균 처리율에 따라 현재 윈도 상태를 계산하므로 짧은 시간에 물리는 트래픽에 대응하기 좋다, 메모리 효울 역시 좋음<br></strong>
<strong>단점: 직전 시간대에 도착한 요청이 균등하게 분포되어 있다는 가정 때문에 다소 느슨하지만 큰 문제가 되지는 않는다.</strong>

## 상세 설계

### 분산 환경에서 처리율 제한 구현
분산처리에는 2가지 어려운 문제가 있다.<br>
<strong>1. 경쟁 조건 <br></strong>
경쟁 조건을 해결하기 위한 해결책은 락 이지만 시스템 성능을 떨어트리는 문제가 있어 루아 스크립트 혹은 정렬집합이라 불리는 레디스 자료구조를 사용해서 해결한다.<br>
<strong>2. 동기화 이슈 <br></strong>
고정세션을 활용해서 클라이언트의 요청을 같은 처리율 제한 장치로 보낼수는 있지만 확장성이 떨어지는 문제가 있다 따라서 중간에 <strong>Redis(중앙 집중형 데이터 저장소)</strong>를 추가하여 처리하는게 바람직하다.

# 5장 안정해시 설계 
데이터를 서버에 균등하게 나누는 목표를 달성하기 위해 사용하는 기술로 안정해시가 있다. 안정해시는 k/n의 키만 재배치하는 해시 기술이다.
## 기본구현법
- 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치
- 키의 위치에서 링을 시계방향으로 탐색 후 최초 발견 서버가 키가 저장될 서버로 선택<br>

<strong>문제점: 파티션 크기를 균등하게 유지하는게 불가능하며 균등 분포를 달성하기 어렵다는 문제가 있다.</strong>

## 가상노드 구현
- 실제 노드 혹은 서버를 가르키는 노드로 여러개의 가상 노드를 가질 수 있다.
- 링을 탐색 중 만나는 최초의 가상 노드가 해당 키가 저장될 서버가 된다.<br>

<strong>고려할점: 가상 노드 수를 늘리면 분포는 더 균등해지지만 저장할 공간이 많이 필요함으로 타협적 결정이 필요하다</strong>

## 안정해시가 주는 이로움
- 서버가 추가되거나 삭제할때 재배치되는 키의 수가 최소화
- 핫스팟 문제 감소
- 수평적 규모 확장성을 달성하기 쉽다.