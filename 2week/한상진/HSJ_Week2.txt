# 단일 서버
- 웹 브라우저, 웹 서버, DNS가 있을때 사용자의 요청이 어떻게 처리되는 과정
- EX) Naver에 접속한다고 가정
    1. www.naver.com를 주소창에 입력
    2. DNS서버에 도메인 주소(www.naver.com)을 IP 주소로 변환
    3. DNS서버에서 www.naver.com에 맞는 IP 주소를 반환.
    4. 반환 받은 IP에 HTTP 요청을 전달.
    5. 요청을 받은 웹 서버는 요청을 HTML 페이지나 JSON 형태로 응답을 반환.

# 데이터베이스
- 사용자가 늘어나게 된다면 트래픽 처리 서버(웹 계층)과 데이터베이스 서버(데이터 계층)을 분리하여 확장
    - 트래픽 처리 서버 : 사용자로부터의 요청을 받아들이고 응답을 생성하여 제공하는 서버
    - 데이터베이스 서버 : 데이터의 저장, 관리, 검색 등을 담당하는 서버

## 데이터베이스 종류

### 관계형 데이터베이스(RDBMS)

- 자료를 테이블과 열, 칼럼으로 표현.
- 조인 연산이 가능.

### 비 관계형 데이터베이스(NoSQL)

- 이것들은 4개로 또 분리될 수 있다.
    - 키-값 저장소(key-value store)
    - 그래프 저장소(graph store)
    - 칼럼 저장소(column store)
    - 문서 저장소(document sotre)
- 일반적으로 조인 연산이 불가능.

## 비 관계형 데이터베이스를 사용하는 경우

- 아주 낮은 응답 지연시간이 요구됨
- 비정형 데이터를 다루는 경우
- 데이터를 직렬화하거나 역직렬화할 수 있기만 하면 됨
- 아주 많은 양의 데이터를 저장할 필요가 있음

<aside>
💡 NoSQL이 빠른 이유는 키-값인 경우 데이터를 읽는데에 최적화된 자료구조를 사용하기 때문이다. NoSQL 키-값 저장소는 접근 속도가 O(1)인 HashMap을 일반적인 RDB는 O(N)인 배열을 사용한다.

</aside>

# 수직적 규모 확장 VS 수평적 규모 확장

## 수직적 규모 확장 (Scale Up)

- 기존 서버의 자원을 업그레이드해 시스템을 확장
- CPU나 RAM 등을 추가
- 트래픽 양이 적을 때 단순한 해결 방법
- **확장에 한계가 존재**

## 수평적 규모 확장 (Scale Out)

- 서버를 여러 대 추가하여 시스템을 확장
- 서버에 걸리는 부하를 균등하게 분배하는 **‘로드밸런서’** 도입이 필수적.

# 로드밸런서
- 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 **트래픽 부하를 고르게 분산**하는 역할
- 사용자는 로드밸런서의 Public IP로 접속하면, 로드밸런서가 같은 네트워크에 속한 웹서버에 Private IP로 요청을 분배.

<aside>
💡 **`Private IP`**는 같은 네트워크에 속한 서버 사이의 통신에서만 쓰이는 IP 주소로 인터넷을 통해서는 접속할 수 없다

</aside>

- 로드밸런서를 추가하면 자동복구 문제도 해소되고, 가용성도 증가
    - 서버1이 죽으면 복구되는동안 서버2로 트래픽을 주면 됨.
    - 트래픽이 과도하게 증가한다 싶으면 서버를 증설.
- 로드밸런서를 통해 웹 계층(트래픽 처리 서버)의 문제는 해결.

# 데이터베이스 다중화

**앞에서 트래픽 처리 서버의 문제를 해결했다면, 이제는 데이터베이스 서버의 문제를 해결할 차례!!**

- 데이터베이스를 `Master-Slave`로 나눔.
    - `**Master` 서버**
        - 쓰기 연산만 지원, 데이터 원본을 저장
    - `**Slave` 서버**
        - 읽기 연산만 지원, 데이터 사본을 저장.
- 대부분의 어플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높기 때문에, Slave 서버의 수가 Master 서버의 수보다 많다.
- **장점**
    - 더 나은 성능: 주-부 다중화 모델에서 모든 데이터 변경 연산은 master으로, 읽기 연산은 slave로 분산되어 병렬로 처리할 수 있는 질의(query)의 수가 늘어나 성능이 향상된다.
    - 안정성(reliability): 자연 재해 등의 이유로 DB 서버 일부가 파괴되어도, 데이터가 보존된다. 데이터를 지역적, 물리적으로 떨어진 장소에 다중화시켜 놓을 수 있기 때문
    - 가용성(availability): 데이터를 여러 곳에 복제해 두어, 하나의 DB 서버에 장애가 발생하더라도 다른 서버의 데이터를 가져와 계속 서비스할 수 있게 된다.

## 로드밸런서, DB 다중화를 고려한 설계안

1, 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.

2. 사용자는 해당 IP 주소로 로드밸런서에 접속한다.

3. HTTP 요청은 서버1 또는 서버2로 전달된다.

4. 웹 서버는 사용자의 데이터를 slave DB 서버에서 읽는다. 데이터 변경 연산은 master DB 서버로 전달한다.

---

위에서는 웹 계층, 데이터 계층에 대해 이해. 지금부터는 응답시간을 개선할 예정

# 캐시

- 값 비싼 연산 결과나 자주 참조되는 데이터를 메모리 안에 두고 요청에 대한 처리를 빨리하도록 도와주는 저장소.

## 캐시 계층

- 데이터가 잠시 보관되는 곳
- 데이터베이스보다 훨씬 빠르고 데이터베이스의 부하도 줄일 수 있다.
- 캐시 계층의 규모를 독립적으로 확장시키는 것도 가능

## 캐시 사용 시 유의할 점

- 갱신은 자주 일어나지 않지만, 참조는 자주 일어나는 경우 캐시 사용
- 캐시는 휘발성 메모리이므로, 영속적으로 보관할 데이터 보관 X
- 캐시에 보관된 데이터의 만료 정책을 마련해 둬야 한다.
- 데이터 저장소의 원본과 캐시 내의 사본이 같은지, 즉 일관성을 유지하는지 확인이 필요.
- 캐시 서버를 하나로 두면 해당 서버는 **단일 장애 지점**이 되어버릴 가능성이 있다. 때문에 여러 지역에 걸쳐 캐시 서버를 분산 시켜야 한다.

<aside>
💡 단일 장애 지점(Single Point of Failure, SPOF)는 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우 그 지점을 단일 장애 지점이라고 부른다.

</aside>

- 캐시 메모리가 작다면 데이터가 밀려나면서 자주 갱신되기에 성능이 저하됨. 이를 해결하기 위해 캐시 메모리는 크게 잡는 방법이 사용됨.
- 캐시가 꽉 차면 기존 데이터를 내보내고 데이터를 추가해야 하는데, 자주 쓰이는 알고리즘은 LRU(Least Recently Used)방식이다. 외에 LFU, FIFO 등이 있다.

# 콘텐츠 전송 네트워크(CDN)

- 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크.
    - 사용자가 웹 사이트를 방문할 때 서버의 데이터는 사용자의 컴퓨터에 도달하기 위해 인터넷을 통해 이동해야 함.
    - 이 때 해당 서버가 멀리 떨어져 있는 경우 대용량 파일을 로드하는 데 시간이 오래 걸립니다.
    - 그 대신 웹 사이트 콘텐츠는 지리적으로 사용자와 가까운 CDN 서버에 저장되며 컴퓨터에 훨씬 빨리 도달하게 만듬
    
- **이미지, 비디오, CSS, JavaScript 파일** 등을 캐시
- 요청 경로(request path), 질의 문자열(query string), 쿠키(cookie), 요청 헤더(request heaer) 등의 정보에 기반하여 HTML 페이지를 캐시

1. 사용자가 이미지 URL을 이용해 **image.png(이미지 파일)**에 접근한다. URL의 도메인은 CDN 서비스 사업자가 제공한 것이다.

2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본 서버(웹 서버 또는 AWS S3와 같은 클라우드 저장소)에 요청하여 **이미지 파일**을 가져온다.

3. 원본 서버가 파일을 CDN 서버에 반환한다. 응답의 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지 설명하는 TTL(Time-to-live) 값이 들어있다.

4. CDN 서버는 **파일**을 캐시하고 사용자 A에게 반환한다. **이미지**는 TTL에 명시된 시간이 끝날 때까지 캐시된다.

5. 다른 사용자 B가 같은 **이미지**에 대한 요청을 CDN 서버에 전송하면

6. 만료되지 않았다면 **이미지** 요청은 캐시를 통해 처리된다.

## CDN 사용 시 고려해야 할 사항

- 비용
    - 보통 제 3 사업자(third-party providers)에 운영되며, CDN으로 들어가고 나가는 데이터 전송 양에 따라 비용이 청구
    - 따라서 자주 사용하지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않으므로 CDN에서 뺌.
- 적절한 만료 시한 설정
    - 만료 시한이 긴 경우 콘텐츠의 신선도는 떨어짐.
    - 만료 시한이 짧은 경우 원본 서버에 빈번히 접속하게 되어 비효율적.
- CDN 장애에 대한 대처 방안
    - CDN 자체가 죽었을 경우 웹사이트/ 어플리케이션이 어떻게 동작해야 하는지 고려.
    - EX) CDN이 응답하지 않는 경우, 원본 서버로 직접 콘텐츠를 가져오도록 클라이언트를 구성.
- 콘텐츠 무효화 방법
    - 만료되지 않은 콘텐츠를 CDN에서 제거
        1. CDN 서비스 사업자가 제공하는 API로 콘텐츠 무효화
        2. 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝(object versioning) 이용

# 무상태(Stateless) 웹 계층

- 웹 계층을 수평적으로 확장하기 위해서는 로드 밸런서를 이용한다 말고도 웹 계층에서 상태 정보(사용자 세션 데이터 등)를 제거해야 한다.

## 상태 정보 의존적인 아키텍처
- 상태 정보 의존적인 아키텍처에서는 **사용자에 따라 항상 같은 서버에 요청을 보내야한다**
    - 사용자 A, B, C는 각각 서버 1,2,3가 각 세션 데이터와 사용자 상태 정보를 갖고 있으므로, 유저가 **http 요청**을 보낼때 **해당하는 서버에 전송**해야 한다.
- 문제는 **같은 클라이언트로부터의 요청이 항상 같은 서버로만 전송되어야 한다는 점**이다.
- 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션(sticky session)이라는 기능을 제공하고 있지만, 이는 **로드밸런서에 부담을 준다**.
- 게다가 추가적으로 서버를 늘리거나 제거할 때도 예기치 않은 장애를 일으킬 수 있고 로드밸런서 설정을 건드려줘야하기에 까다로워진다.

## 무상태 아키텍처
- 사용자로부터의 HTTP 요청은 어떤 웹서버로도 전달됨.
- 상태 정보가 필요한 경우공유 저장소로 부터 사용자 상태 정보를 가져온다.
    - 상태 정보는 웹 서버로부터 물리적으로 분리되어 있는 상태.
- 무상태 아키텍처는 요청에 대해 물리적으로 분리해줄 필요가 없기에 부담없이 웹 서버를 수평적으로 확장할 수 있고 이처럼 단순하고 안정적이라 규모확장에도 이점이 있다

## 무상태 웹 계층을 갖는 설계
- 여기서는 NoSQL을 사용했지만, 공유 저장소는 Redis 같은 캐시 시스템이나 RDB일 수도 있다.
- 전 세계 사용자가 쾌적하게 사용하기 위해서는 여러 **데이터 센터**를 지원하는 것이 필수

# 데이터 센터
- 위의 그림은 2개의 데이터 센터를 이용하는 경우의 구조도
- 장애가 없는 상황에서 사용자의 요청은 가장 가까운 데이터 센터로 안내되는데, 이를 **지리적 라우팅(geoDNS-routing, geo-routing)**이라 부른다

## 데이터 센터 장애 발생 시
- 데이터 센터 중 하나에 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송됨.
    - 위의 경우 DC2 US-West 데이터 센터가 장애가 생긴 경우.
- 다중 데이터센터 아키텍처를 만들기 위해 해결해야 하는 기술적 난제
    - 트래픽 우회 : 올바른 데이터센터로 요청을 보내는 방법을 생각해야한다.
    - 데이터 동기화 : 데이터를 여러 데이터센터에 걸쳐 다중화 처리를 함.
    - 테스트와 배포 : 다양한 환경에서 테스트해보고 배포.

더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트들을 분리하여 각기 독립적으로 확장 될 수 있도록 도와줄 필요가 있는데 이를 도와주는 것이 **메시지 큐(Message Queue)**이다.

# 메시지 큐

- 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트
    - 무손실 : 메세지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관되는 특성
- 생산자 또는 발행자(producer, publisher)라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다.
- 큐에는 보통 소비자 혹은 구독자(consumer, subscriber)라 불리는 서비스 혹은 서버가 연결되어 있는데, 메시지를 받아 그에 맞는 동작을 수행.
- 메시지 큐 이용 시 장점
    - 서비스 또는 서버 간 **결합이 느슨해**져, 규모 확장성이 보장되어야 하는 애플리케이션을 구성하기 좋다.
    - **생산자는 소비자가 프로세스가 다운되어 있어도, 메시지를 발행할 수 있고, 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.**

# 로그, 메트릭 그리고 자동화

- 웹 사이트의 규모가 커지고 나면, 로그나 메트릭, 자동화 도구를 필수적으로 포함시켜야 한다.
    - **로그: 시스템의 오류와 문제들을 쉽게 찾아**낼 수 있음.
        - 에러 로그를 서버 단위, 또는 단일 서비스로 모아주는 도구를 활용하여 더 편리하게 검색하고 조회 가능
    - **메트릭(metric)**: 메트릭 수집을 통해 사업 현황에 관한 유용한 정보를 얻을 수 있고, **시스템의 현재 상태를 손쉽게 파악 가능**하다.
        - 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O 관련 메트릭
        - 종합 메트릭: DB 계층의 성능, 캐시 계층의 성능
        - 핵심 비즈니스 메트릭: 일별 능동 사용자(daily active user), 수익(revenue), 재방문(retention) 기록
    - **자동화(automation**) : 지속적 통합, 배포(CI/CD) 도구를 사용하는 경우 **문제를 쉽게 감지**할 수 있고, **개발 생산성을 크게 향상**시킬 수 있다.

## 메시지 큐, 로그, 메트릭, 자동화 등을 반영한 설계

# 데이터베이스의 규모 확장

저장할 데이터가 많아지면 데이터베이스에 대한 부하 증가 → 데이터베이스 증설 어케 할지

## 수직적 확장(Scale Up)

- 기존의 서버에 고성능의 자원을 증설하는 방법
- 고성능의 자원을 추가하여 더 많은 양의 데이터를 보관하고 처리함.
- 문제점
    - 서버 하드웨어에는 한계가 존재 → 무한히 증설할 수 없음.
    - SPOF로 인한 위험성
    - 비용이 많이 듬.

## 수평적 확장(Scale Out) == 샤딩

- 데이터베이스의 수평적 확장 == 샤딩
    - 더 많은 서버를 추가함으로써 성능을 향상.

### 샤딩

- 대규모 데이터베이스를 샤드(Shard)라고 부르는 작은 단위로 분할하는 기술.
- 샤드는 같은 데이터 스키마를 쓰지만, 샤드에 보관되는 데이터 사이에는 중복이 없음.

### 샤딩 전략 구현 시 고려해야 할 점

- 샤딩 전략 구현 시 가장 중요한 것은 **샤딩 키(sharding key, partition key)**의 설정
    - 샤딩 키 : 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성됨.
    - 위의 예시에서는 user_id가 샤딩 키 이다.
- 샤딩 키를 통해 올바른 데이터베이스에 질의를 보내 데이터 조회나 변경을 처리하여 효율을 높일 수 있다.
- 샤딩 키를 정할 때는 **데이터를 고르게 분할 할 수 있도록** 하는게 가장 중요.

### 샤딩 도입 시 풀어야 할 문제

- 데이터의 재샤딩
    - 데이터가 너무 많아져 하나의 샤드로 감당하기 어렵거나, 샤드 간 데이터 분포가 균등하지 못해 어떤 샤드에 할당된 공간 소모가 다른 샤드보다 빠르게 진행될 때, 데이터 재배치가 필요.
- 유명인사 문제
    - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
- 조인과 비정규화
    - 여러 샤드에 걸친 데이터를 조인하기 힘들어짐
    - DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 방법으로 해결.

# 개략적인 규모 추정

- 보편적으로 통용되는 성능 수치상에서 사고 실험을 행하여 추정치를 계산하는 행위
- 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것임.
- 규모 확장성을 표현하는 데 필요한 기본기 3가지
    - 2의 제곱수
    - 응답지연 값
    - 가용성에 관계된 수치들

## 1) 2의 제곱수

- 분산 시스템에서 다루는 데이터 양을 제대로 계산하기 위해서는 **데이터 볼륨의 단위**를 2**의 제곱수로 표현**할 수 있어야 한다.
- 최소 단위는 1 Byte == 8 Bit
    - ASCII 문자 하나가 차지하는 메모리 크기 = 1 Byte

## 2) 응답지연 값

- 통상적인 컴퓨터에서 구현된 연산들의 응답지연 값

- 위의 표를 통한 결론
    - 메모리는 빠르지만 디스크는 아직도 느리다.
    - 디스크 탐색(seek)은 가능한 한 피하도록
    - 단순한 압축 알고리즘은 빠르다.
    - 데이터를 인터넷으로 전송하기 전에 가능하면 압축하기
    - 데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터 전송에는 시간이 오래 걸린다.

## 3) 가용성에 관계된 수치들

### 고가용성(High Availability)

- 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력.
- 고갸용성을 표현하는 값은 퍼센트로 표현한다
    - ex) 100% → 시스템이 단 한 번도 중단된 적이 없음을 의미.

### SLA(Service Level Agreement)

- 서비스 사업자가 보편적으로 사용하는 용어로, 서비스 사업자와 고객 사이에 맺어진 합의.
- **SLA**에는 서비스 사업자가 **제공하는 서비스의 가용시간**이 공식적으로 기술됨.
    - ex) 아마존, 구글 등은 99% 이상의 SLA 를 제공.

# 개요

## 시스템 설계 면접

- 2명의 동료가 모호한 문제를 풀기 위해 협력하여 해결책을 찾아가는 과정
- 때문에 정답도 없고 결과도 없다.
- 설계과정에서 내린 결정에 대해 방어하는 능력을 보는 과정이고, 면접관의 피드백을 건설적인 방향으로 처리할 자질이 있음을 보는 면접

# 시스템 설계 면접을 위한 4단계 접근법

## 1단계 : 문제 이해 및 설계 범위 확정

- 시스템 설계 면접을 볼 때 **생각 없이 바로 답을 내서는 좋은 점수를 받기 어렵다**
- 답부터 들이밀지 말고, **속도를 늦추는 것이 좋음**. 깊이 생각하고 질문하여 **요구사항과 가정들을 분명히 해야 한다**
- 요구사항 이해를 위한 질문
    - 어떤 기능을 만들어야하는가?
    - 제품 사용자 수는 얼마나 되는가?
    - 회사의 규모가 얼마나 빨리 성장할 것 같은가? 3개월 뒤, 6개월 뒤 규모가 얼마가 되리라 생각해야하는가?
    - 회사가 주로 사용하는 기술 스택은 무엇인가?

## 2단계 : 개략적인 설계안 제시 및 동의 구하기

- 개략적인 설계안을 제시하고 면접관의 동의를 얻어 내는 단계
    - **설계안의 최초 구성도를 제시**하고 의견을 구하라. 팀원인 것처럼 대하라. 훌륭한 면접관들은 지원자와 대화하고 설계하는걸 즐긴다.
    - 화이트보드나 종이에 **핵심 컴포넌트**를 그려라. CDN, 클라이언트, 웹 서버, 데이터베이스 서버, 캐시 등이 포함될 수 있다.
    - 이 설계안이 제약사항을 만족하는지 개략적으로 계산하자. 그 과정은 소리내어 설명하고 계산이 필요한지도 물어봐야한다.
- 예를 들어, “뉴스 피드 시스템을 설계하라” 라는 질문이 들어온다면
    - 2가지 처리 flow로 나눠 생각할 수 있음
        1. 피드 발행 : 사용자가 포스트를 올리면 관련된 데이터가 캐시/데이터베이스에 기록되고 친구의 뉴스피드에 뜨게 된다.
        2. 피드 생성 : 사용자의 뉴스 피드는 해당 사용자의 친구들의 포스트를 시간 역순으로 정렬하여 만든다.

## 3단계 : 상세 설계

- 3단계에서는 실제 대상 컴포넌트 사이의 우선순위를 결정해야 함.
- 면접관이 집중 했으면 하는 영역을 알려 줄 수도 있음.
- 또는 시스템의 성능 특성에 대한 면접관의 질문에 시스템의 병목 구간이나 자원 요구량 추정치에 초점을 맞춰 대답을 할 수도 있음.

## 4단계 : 마무리

- 후속 질문이 들어올 수도 있고, 스스로 추가 논의를 진행할 수도 있다.

# 정리

## **해야 할 것**

- 질문을 통해 확인하라(clarification). 스스로 내린 가정이 옳다 믿고 진행하지 말라.
- 문제의 요구사항을 이해하라.
- 정답이나 최선의 답안 같은 것은 없다는 점을 명심하자. 요구사항을 정확히 이해했는지 다시 확인하라.
- 면접관이 사고의 흐름을 이해할 수 있도록 하라, 면접관과 소통하라.
- 가능하다면 여러 해법을 함께 제시하라.
- 개략적 설계에 면접관이 동의하면, 각 컴포넌트의 세부사항을 설명하기 시작하라. 가장 중요한 컴포넌트부터 진행하라
- 면접관의 아이디어를 이끌어 내라. 좋은 면접관은 팀원처럼 협력할 것이다.

## **하지 말아야 할 것**

- 전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 말라.
- 요구사항이나 가정들을 분명히 하지 않은 상태에서 설계를 제시하지 말라.
- 처음부터 특정 컴포넌트의 세부사항을 너무 깊이 설명하지 말라. 개략적 설계를 마친 뒤 세부사항으로 나아가라.
- 진행 중 막혔다면, 힌트를 청하기를 주저하지 말라.
- 소통을 주저하지 말라.
- 설계안을 내놓은 순간 면접이 끝났다고 생각하지 말고, 의견을 일찍 그리고 자주 구하라.

## **시간 배분**

- 45분 면접 시간을 가정
    - 1단계 (문제 이해 및 설계 범위 확정) - 3분에서 10분
    - 2단계 (개략적 설계안 제시 및 동의 구하기) - 10분에서 15분
    - 3단계 (상세 설계) - 10분에서 25분
    - 4단계 (마무리) - 3분에서 5분