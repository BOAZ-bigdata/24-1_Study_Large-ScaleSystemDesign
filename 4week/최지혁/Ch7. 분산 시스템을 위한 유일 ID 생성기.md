분산 시스템에서는 `auto_increment`속성이 설정된 관계 데이터 베에스의 기본 키 사용이 불가능하다. 
- 서버 한대로는 감당이 안되기도 하고 여러 서버를 쓰는 경우 delay 를 낮추기가 무척 힘들기 때문이다.
# 1단계 문제 이해 및 설계 범위 확정
지원자와 면접자의 문답 예시

- 지원자: ID의 특성은?
- 면접관: 유일하고 정렬가능 해야해^^

- 지원자: 새로운 레코드에 붙일 ID 값은 항상 1만큼 커야 하는지?
- 면접관: 언제나 1씩 증가한다고는 할 수 없지만 ID는 아침에 만든 것 보다 저녁에 만든게 더 큼

- 지원자: ID는 숫자로만?
- 면접관:ㅇㅇ

- 지원자: 지원자 규모는?
- 면접관: 초당 10000ID 생성

즉 알 수 있는 요구 사항은 다음과 같다.
- ID는 유일해야 한다. (unique)
- ID는 숫자로만 구성되어있어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야한다.
- ID는 64비트로 표현될 수 있는 값이어야한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

# 2단계 개략적인 설계안 제시 및 동의 구하기
분산시스템에서 유일성이 보장되는 ID를 만드는 방식은 다음과 같은 것이 있다.

- 다중 마스터 복제 (multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노플레이크 접근법

각각의 장단점 및 동작원리를 알아보자

## 다중 마스터 복제
다중 마스터 복제는 아래와 같은 구성을 갖는다.
![다중 마스터 복제](https://daeakin.github.io//images/large-system/multi-master%20replication.png)
- 이 접근법은 데이터베이스의 auto_increment 기능을 활용하는 것으로 ID 값을 구할 때 DB 서버 수인 k 만큼 증가시킨다.
- 규모확장성 문제를 어느정도 해결할 수 있으나 다음과 같은 큰 단점이 있다.
#### 단점
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

## UUID
#### UUID란?
- **컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리 수이다.**
- UUID 값은 충돌 가능성이 지극히 낮다. 
- UUID 값은 서버간 조율 없이 독립적으로 생성 가능하다.

다음과 같은 형태를 지닌다.
```null
f2195bf4-4eb1-11ed-bdc3-0242ac120002
```

![](https://daeakin.github.io//images/large-system/UUID.png)

#### 장점
- UUID를 만드는 것은 단순하다. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.
#### 단점
- ID가 128비트로 길다. 이전의 ID 요구사항은 64비트이다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

## 티켓 서버
플리커에서 이 기술을 채택하고 있으며 개략적인 구조는 다음과 같다.
![티켓 서버](https://daeakin.github.io//images/large-system/ticket-server.png)

이 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터 베이스 서버를 중앙 집중형으로 하나만 사용하는 것이다.

#### 장점
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고 중소 애플리케이션에 적합하다.
#### 단점
- 티켓 서버가 SPOF 가 된다.
- 티켓 서버를 여러대 두변 되긴 하지만 새로운 동기화문제가 또 발생한다.

## 트위터 스노플레이크 접근법
스노플레이크 접근법은 각개격파 전략을 활용한다. 바로 생성해야 하는 ID의 구조를 여러 절로 분할하는 것이다.
![스노플레이크 접근법](https://daeakin.github.io//images/large-system/snowflake.png)
분할한 각 절의 쓰임새르 살펴보자
- 사인(sign)비트: 1비트를 할당한다. 지금으로서는 쓰임새가 없지만 나중을 위해 유보해둔다. 음양 구별을 위해 사용될 수 있다.
- timestamp: 41비트를 할당한다. 기원시각(epoch)이후로 몇 밀리초가 경과 했는지 나타내는 값이다.
- 데이터 센터ID: 5비트를 할당한다. 따라서 데이터 센터당 32개의 서버를 이용할 수 있을 것이다.
- 일련번호: 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다. 이 일련번호를 1만큼 증가 시킨다. 이 값은 1밀리초가 증가할 때마다. 0으로 초기화 된다.

# 3단계 상세설계
이번 설계에서는 스노플레이크 접근법을 사용해 시스템 설계를 진행할 예정이다.
- 데이터 센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 운영중에는 변경되지 않는다.
- 때문에 취급하는데 주의가 필요하다.
- 일련번호와 timestamp는 ID 생성기가 돌고 있는 와중에 만들어지는 값이다.

## 타임 스탬프
타임 스탬프는 시간이 흐를 수록 점점 큰값을 가질 수 있으므로 결국 시간 순으로 정렬이 가능하다.
아래는 ID값을 따르는 이진 표현으로 부터 UTC 시각을 추출하는 한 예이다.
![](https://daeakin.github.io//images/large-system/timestamp.png)
41비트로 표현될 수 있는 타임스탬프의 최댓값은 (2^41 - 1)로 대략 69년에 해당한다.
때문에 69년 동안만 정상 작동하며 그 이후에는 기원시간을 바꾸거나 ID체계를 다른 것으로 이전해야 한다.

## 일련번호
일련번호는 12비트로 4069개의 값을 가질 수 있으나 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 가진다.

# 4단계 마무리
우리는 스노플레이크 방식을 선택했는데 이유는 다음과 같다.
- 모든 요구사항을 만족하면서도 분산환경에서 규모확장이 가능했기 때문이다.

설계를 진행하고 시간이 좀 남았다면 면접관과 다음을 추가로 논의해도 괜찮다.

- 시계동기화: 이번 설계의 가정은 ID 생성 서버들이 모두 같은 시계를 사용한다고 가정한 것이다. 이러한 가정은 하나의 서버가 여러 코어에서 실행될 경우 꺠질 수 있는데 그때 문제되는 것이 시계동기화 문제다.
	- NTP가 이 문제를 해결하는 가장 보편적 수단이다.
	- 단조시계 vs 일기준 시계
	- 다만 NTP를 사용하더라도 시계 드리프트 현상이 발생하고 이 경우 데이터에 조용하고 미묘한 손실이 발생하기 쉽다.
	- 나중에는 그래서 사간 차이의 신뢰구간을 이용하는 등 방법이 심오해진다.
- 각 절의 길이 최적화: 예시로 **동시성이 낮고 수명이 긴 애플리케이션**이라면 **일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적**일 수 있다.
- 고가용성: ID 생성기는 필수불가결 컴포넌트이므로 아주 높은 가용성을 제공해야 할 것이다.

