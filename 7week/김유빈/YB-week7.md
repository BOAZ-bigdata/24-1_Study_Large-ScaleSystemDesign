# 12. 채팅 시스템 설계

## 문제 이해 및 설계 범위 확정
채팅 앱에는 아래와 같은 앱들이 존재한다. → 면접에서 원하는 앱은 정확히 무엇인지 파악해야.
- 페이스북 메신저, 위챗, 왓츠앱과 같이 1:1 채팅에 집중한 앱
- 슬랙처럼 그룹 채팅에 중점을 둔 업무용 앱
- 디스코드처럼 대규모 그룹 소통과 응답 지연이 낮은 음성 채팅에 집중하는 앱

### 요구사항
- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 가능한 그룹 채팅 기능
- 사용자 접속상태 표시 기능
- 다양한 단말 지원 및 한 계정 여러 단말 동시 접속 지원
- 푸시 알림
- 5천만 DAU 지원

## 개략적인 설계안 제시 및 동의 구하기

클라이언트는 서로 직접 통신하지 않음. **채팅 서비스의 기본 기능에 집중**

- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우, 접속 시까지 해당 메시지 보관

**어떤 프로토콜을 사용할 것인가?**

- 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이다.
   - 채팅 시스템에서 메시지 송신 클라이언트가 해당 역할을 수행한다.
- HTTP 프로토콜을 사용하여 연결 후 송신자는 채팅 서비스에 수신자에게 메시지 전달을 요청한다.
- 여기서는 keep-alive 헤더를 사용하면 효율적이다.
   - TCP 접속과정에서 발생하는 handshake 횟수를 줄일 수 있다.

**메시지 수신은 어떤 프로토콜을 사용할 것인가?**
- HTTP는 클라이언트가 연결을 생성하는 프로토콜이다.
   - 서버에서 클라이언트에게 임의 시점에 메시지 전달은 어렵다.
- 이를 해결하기 위한 폴링, 롱 폴링, 웹 소켓 기술 사용가능

### 폴링
- 클라이언트가 주기적으로 서버에게 메시지 여부를 물어보는 방식이다.
- 폴링 비용은 주기가 짧을수록 올라간다.
- 답할 메시지가 없을 경우 서버 자원이 낭비된다.

### 롱 폴링
- 폴링의 단점을 보완한 기법
- 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.
- 클라이언트는 새 메시지를 받으면(또는 타임아웃 시) 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.
- 약점
- 송신자와 수신자가 같은 채팅 서버에 접속하지 않을 수 있다.
- HTTP 서버들은 대부분 stateless 서버이며, 로드 밸러싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 송신자와 수신자가 다른 채팅 서버를 사용할 수 있다.
- 서버 입장에서 연결 해제 여부를 알 수 없다.
- 메시지를 받지않은 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 재접속해야하므로 여전히 비효율적이다.

## 웹소켓
- 웹 소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.
- 연결은 클라이언트가 시작한다.
처음에 HTTP 연결 후, 특정 handshake 절차를 거치고 웹 소켓 연결로 업그레이드된다.
- 항구적이며 양방향이다.
- HTTP/HTTPS의 80 또는 443 포트를 그대로 사용하기 때문에 방화벽 환경에서도 동작한다.

### 개략적 설계안
- 채팅을 제외한 대부분의 기능(회원가입, 로그인, 사용자 프로필 등)은 일반적인 HTTP로 구현해도 된다.
- 채팅 시스템의 종류
   - stateless(무상태) 서비스
   - stateful(상태유지) 서비스
   - third-party 연동

**무상태 서비스**
- 로그인, 회원가입, 사용자 프로필 등 전통적인 요청/응답이 해당된다.
- 무상태 서비스는 로드밸런서 뒤에 위치한다.
   - 로드밸런서 뒤에는 모놀리틱 또는 마이크로서비스일 수도 있다.
- 서비스 탐색(service discovery) 서비스는 클라이언트가 접속할 채팅 서버의 DNS - 호스트명을 알려주는 서비스이다.

**상태 유지 서비스**
- 채팅 서비스가 해당된다.
- 각 클라이언트와 채팅 서버는 독립적인 네트워크 연결을 유지해야한다.
   - 클라이언트는 서버와 연결이 살아있는 한 다른 서버로 연결을 변경하지 않는다.
- 서비스 탐색 서비스는 채팅 서비스와 협력하여 특정 채팅 서버에 부하가 몰리지 않도록 한다.

**제3자 서비스 연동**
- 푸시 알림이 해당된다.
- 앱이 실행 중이 아니어도 알림을 받아야한다.
- 상세 내용은 챕터 10장. 알림 시스템 설계 참고

**규모 확장성**
- 채팅서버는 클라이언트 간 메시지 중계를 담당한다.
- 접속상태(presence) 서버는 사용자 접속 여부를 관리한다.
- API 서버는 채팅을 제외한 로그인, 회원가입 프로필 변경 등 전부를 처리한다.
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소에는 채팅 이력을 보관한다.
   - 시스템에 접속한 사용자는 이전 채팅 이력을 전부 볼 것이다.

**저장소**
- 어떤 데이터베이스를 사용할 것인지는 데이터의 유형과 읽기/쓰기 연산의 패턴을 봐야한다.
- 채팅 시스템의 데이터
   - 사용자 프로필, 설정, 친구 목록 등 일반 데이터
   - 채팅 이력 (chat history)
- 일반 데이터는 데이터 안정성을 보장하는 관계형 데이터베이스에 보관한다.
- 채팅이력은 읽기/쓰기 연산 패턴을 이해해야한다.
   - 채팅 이력 데이터는 매우 크다.
      - 페이스북 메신저나 왓츠앱은 매일 600억 개의 메시지를 처리한다.
   - 이 데이터에서 가장 자주 사용되는 것은 최근 메시지이다.
      - 대부분 사용자는 오래된 메시지를 보지않는다.
- 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1이다.

- 위 사항을 바탕으로 채팅 이력은 키-값 저장소를 추천한다.
   - 수평적 규모확장이 쉽다.
   - 데이터 접근 지연시간이 낮다.
- 관계형 데이터베이스는 long tail에 해당하는 부분을 잘 처리하지 못한다
- 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 사용한다.

### 데이터 모델
**1:1 채팅 메시지 테이블**
- message_id를 기본키로 갖는다.

**그룹 채팅 메시지 테이블**
- channel_id, message_id 복합키를 기본키로 갖는다.

**메시지 ID**
- message_id는 고유해야한다.
- ID는 정렬 가능하며 시간 순서와 일치해야한다.

## 상세 설계
서비스 탐색, 메시지 전달 흐름, 사용자 접속 상태 표시 방법에 대해

## 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
- 기준은 클라이언트의 위치, 서버 용량 등이 있다.
- 대표적으로는 아파치 주키퍼가 있다.
- 사용가능한 모든 채팅 서버를 등록하고 클라이언트가 접속 시도 시, 기준에 따라 최적의 채팅 서버를 골라준다.

## 메시지 흐름
**1:1 채팅 메시지 처리 흐름**
1. A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기로 message_id 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지를 키-값 저장소에 저장

5.a. B가 온라인인 경우, 메시지는 채팅 서버 2로 전송됨.  
5.b. 오프라인인 경우, 메시지를 푸시 알림 서버로 전송

B와 채팅서버 2는 웹소켓으로 연결되어 있으며, 채팅서버 2가 B에게 메시지 전송.

**여러 단말 사이의 메시지 동기화**
- 각 단말은 가장 최신 메시지 ID인 cur_max_message_id를 갖는다.
- 아래 두 조건을 만족한 경우 새 메시지로 간주한다.
   - 수신자 ID가 현재 로그인한 사용자 ID와 같은 경우
   - message_id가 cur_max_message_id보다 큰 경우

**소규모 그룹 채팅에서의 메시지 흐름**
- A가 보낸 메시지는 B와 C의 메시지 큐에 복사된다.
- 새 메시지 여부는 본인 큐만 확인하면 되므로 단순하다.
- 그룹이 크지않으면 큐마다 복사하는 비용이 문제되지 않는다.
- 위챗은 이 방법을 쓰며 그룹 크기를 500명으로 제한한다.

### 접속상태 표시
- 접속상태 표시는 채팅 애플리케이션의 핵심 기능이다.
   - 사용자 프로필 옆에 나타나는 녹색 불이 그것이다.
- 접속 상태 서버는 웹소켓으로 통신하는 실시간 서비스 중 하나이다.

**사용자 로그인**
- 클라이언트가 웹 소켓 연결을 하고나면 접속 상태 서버는 유저 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관한다.

**로그아웃**
로그아웃 시 사용자 상태를 offline으로 바꾼다.
이때 UI 상에 사용자 상태는 접속 중이 아닌 것으로 표시된다.

**접속 장애**
- 인터넷 연결은 항상 안정적인 것은 아니다.
- 잠깐의 연결이 끊겼다고 매번 접속 상태를 변경하는 것은 오버헤드가 크다. ex) 터널
- 이 문제는 heartbeat 검사를 통해 해결할 수 있다.

**상태정보의 전송**
- 친구들(B, C, D)는 A의 상태정보를 어떻게 알까?
- 접속상태 서버는 발행(publish)-구독(subscribe) 모델을 사용한다.
   - 각 친구관계마다 채널을 하나씩 둔다.
   - 위 예시에서는 A-B, A-C, A-D 채널이 존재
   - 각 채널을 각 친구들이 구독

# 13. 검색어 자동완성 시스템


## 문제 이해 및 설계 범위 확정
- 응답지연이 낮은 일대일 채팅 기능 
- 최대 100명 까지 참여할 수 있는 그룹 채팅 기능 
- 사용자의 접속상태 표시 기능 
- 다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림 
- 처리해야 하는 트래픽 규모 : 일별 능동 사용자 수(DAU) 기준으로 5천만 명

### 요구사항

- 빠른 응답속도: 약 100ms 이내여야 함. 아니면 이용이 불편해질 수 있다는 조사가 있음.
- 연관성: 자동완성 된 검색어들은 당연히 연관된 것이여야 함
- 정렬: 인기도 같은 순위모델에 의해 정렬되어야 함
- 규모 확장성 및 고가용성

### 개략적 규모 추정

- DAU 천만명 가정
- 한 사용자가 평균적으로 매일 10건의 검색을 수행한다고 가정
- 질의 때마다 20 바이트의 데이터를 입력한다고 가정

글자를 입력할 때마다 백엔드에 요청

- 즉, 1회 검색 당 20건의 request
- 초당 24,000건의 질의(QPS) (10,000,000 X 10 X 20 / 24 / 3600)
- 최대 QPS = 24,000 X 2 = 48,000


## 개략적인 설계안 제시 및 동의 구하기
시스템을 두 부분으로 나눌 수 있음

- 데이터 수집 서비스: 입력한 질의 수집하는 서비스
- 질의 서비스: 질의에 5개의 인기 검색어를 정렬해 반환하는 서비스

### 데이터 수집 서비스

`질의 단어`와 해당 질의 단어의 `빈도 수`를 저장

- 빈도 테이블 구성

### 질의 서비스

앞서 구성한 빈도 테이블 사용

- `Order by`, `Limit` SQL 질의를 통해 빈도 수 높은 질의 단어 5개를 가져올 수 있다.

요청 당 쿼리 발생

- 요청도 많은데, 데이터도 많아지면? DB가 병목될 것.

## 상세 설계

### 트라이(Trie) 자료구조
트리형태의 자료구조로 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조

- 루트노드는 빈 문자열 나타냄
- 각 노드는 하나의 글자 저장, 최대 26개(알파벳)의 자식 노드를 가질 수 있음
- 리프노드로 가며 하나의 단어, 또는 접두어 문자열을 표현

어떻게 가장 많이 질의된 단어를 찾아낼까?

- 질의로 들어온 단어 또는 접두어를 표현하는 노드를 찾는다
- 해당 노드부터 시작하는 하위 트리를 탐색한다.
- 유효한 검색 문자열을 갖는 노드(유효노드)를 찾는다.
- 유효노드를 정렬해 가장 인기 있는 검색어를 찾는다.

최악의 경우, k개 결과 얻으려고 트라이 다 검색해야 할 수도 있다.

성능을 올릴 수 없을까?

- 접두어의 최대 길이 제한
- 각 노드에 인기 검색어 캐시
    - 노드에 인기 검색어를 저장해야 하므로 공간이 더 필요하다는 단점
    - 빠른 응답속도 필요하면 사용

### 데이터 수집 서비스

매일 수천만 건의 질의

- 그 때마다 트라이 갱신? 실시간적인 인기검색어 변화 적음.  실시간 갱신 필요성 적음.

트라이를 만드는데 사용하는 데이터는 보통 데이터 분석 서비스/로깅 서비스로 부터 온다.

데이터 수집 서비스의 설계안
- Analytics logs: 입력된 질의에 관한 원본 데이터
- Aggregators: Log 취합 및 전처리, DB 저장
- Workers: 비동기적으로 트라이 자료구조 생성 및 저장
- Trie cache: 데이터 메모리에 유지시켜 읽기 연산 성능 높임 → 주기적으로 DB 스냅샷
- Trie DB
    - Document store
    - Key-value store

### 질의 서비스

- 서버 앞 단에서 로드밸런서로 부터 요청을 받음
- 서버로 요청이 들어오면 트라이 캐시에서 데이터 가져옴
- 캐시에 없으면 데이터베이스 조회해 캐시를 채움. 이후 캐시에서 가져옴.

더 생각해봐야하는 최적화 방안

- ajax 요청
    - 클라이언트의 페이지 새로고침 없이 요청 가능
- 브라우저 캐싱
    
    
- 데이터 샘플링
    - 모든 질의를 다 로깅? 자원부족할 수 있다.
    - N개 요청 중 1개만 로깅

### 트라이 연산

트라이 생성

- Workers가 담당
- Analytics logs로 부터 aggregate 된 데이터를 이용해 생성

트라이 갱신

- 주기적으로 새로운 트라이 생성 후 기존 트라이 대체
- 특정 트라이 노드만 대체하면 안되나?
    - 트라이 노드 갱신 시, 상위 노드에서도 질의 결과를 캐시(저장)하고 있기 때문에 상위 노드도 다 업데이트해야하는 번거로움이 있음.

### 검색어 삭제

제한하고 싶은 검색어의 경우 질의 과정에서 서버와 트라이 캐시 사이에 `필터` 를 둬서 제한할 수 있다.


### 저장소 규모 확장

대규모 서비스의 경우, 트라이가 커질 수 있다.

- 글자 기준으로 샤딩 해볼 수 있음. 하지만 특정 글자간 단어가 균등하지 않음.
- `shard map manager` 같은 검색어가 어느 저장소(샤드)에 저장되었는지를 저장하고 있는 컴포넌트를 추가해 관리할 수 있음.


## 마무리

다국어 지원은 어떻게 할 수 있을까?

- 유니코드 사용 필요. 트라이에서 유니코드를 저장할 수 있도록.


국가별로 인기 검색어 순위가 달라야한다면?

- 국가별로 다른 트라이 구성
- CDN 이용 고려해볼 수 있음


실시간성 서비스에도 위 구조가 적용이 가능할까?

- 실시간으로 트라이 업데이트를 진행하지 않으므로 불가.
- 실시간 서비스 시, 고려해봐야 할 점
    - 샤딩 통해 작업 대상 데이터 양 줄이기
    - 최근 검색어에 높은 가중치 부여하기
    - 데이터 스트림 형태 고려 → 스트림 프로세싱 시스템 필요(Apache Hadoop, Apache Spark, Apache Kafka 등)