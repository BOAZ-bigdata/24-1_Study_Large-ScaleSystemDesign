# 1장 사용자 수에 따른 규모 확장성
1장 키워드: `규모 확장성과 관게된 설계 문제`
## 단일 서버
- 웹 앱, 데이터베이스, 캐시 등이 전부 한대의 서버에서 운영되는 방식의 사용자 요청 처리 흐름 
![IMG_2E478D97FA53-1](https://github.com/BOAZ-bigdata/24-1_Study_Large-ScaleSystemDesign/assets/80163835/e572545a-510a-44e0-ab2c-5b33defb1920)

DNS 질의를 통한 IP주소 변환 -> 해당 IP로 HTTP 요청 전달 -> 요청을 받은 웹 서버가 HTML, JSON 형태의 응답을 반환

## 데이터베이스 
- 사용자가 증가할 경우 1. 웹/모바일 트래픽 처리 2. 데이터베이스 용 이렇게 두 개의 서버를 두어야 한다.
- 관계형 데이터베이스(RDBMS): 자료를 테이블과 열, 칼럼으로 표현 / 조인 연산 지원
- 비관계형 데이터베이스(NoSQL): 키-값 데이터 / 조인 연산을 지원하지 않음

NoSQL이 유리한 경우: 낮은 응답 지연시간, 비정형 데이터, 아주 많은 양의 데이터를 저장하는 경우

## 수직적 규모 확장 VS 수평적 규모 확장
- 수직적 규모 확장(Scale-up): 서버에 고사양 자원을 추가
- 수평적 규모 확장(Scale-out): 더 많은 서버를 추가

수직적 확장의 한계: 자원을 무한대로 증설 X, 자동복구 및 다중화 방안을 제시 X -> 서버 장애 발생시 문제

-> 이런 단점으로 인해 대규모 애플리케이션 지원시 수평적 규모 확장법이 적절

### 로드벨런서(수평적확장)
- 부하 분산 집합 안에 속한 웹 서버들에게 트래픽을 고르게 분산하는 역할
- 문제 발생으로 인해 하나의 서버가 다운되면 다른 서버가 역할을 함 -> 장애 대처 가능 + 가용성 향상

-> 로드밸런서를 통해 장애 대처와 가용성을 향상시켰다.

### 데이터베이스 다중화
- Master(쓰기 연산)-Slave(읽기 연산) 구조 
- 데이터베이스 다중화를 통한 이득: 더 나은 성능, 안정성, 가용성, 성능

-> 데이터베이스가 다운되어 `없는 데이터`가 발생할 경우 다중 마스터 / 원형 다중화 방식을 통해 해결할 수 있다.

로드밸런서와 데이터베이스 다중화를 고려한 설계
![IMG_A17E0EFA0B29-1](https://github.com/BOAZ-bigdata/24-1_Study_Large-ScaleSystemDesign/assets/80163835/b32dcf2f-d383-4cd0-8e15-580cda4677ce)

## 캐시
- 데이터를 잠시 보관하는 공간으로 데이터베이스보다 훨씬 빠름
- 데이터 갱신은 자주 일어나지 않지만 참조가 빈번할 경우 고려

**유의사항**
- 더이상 사용하지 않은 데이터를 삭제하기 위한 만료 정책 필요
- 캐시와 저장소간 일관성을 유지하는 방안을 생각해야한다.
- 단일 장애 지점을 피해 여러 지역에 걸쳐 캐시 서버를 분산시킬 필요가 있다. 
- 캐시 메모리를 과할당하여 데이터 과도화시 생길 문제 방지
- LRU, LFU등을 사용하여 데이터 방출을 할것을 고려

## CDN(콘텐츠 전송 네트워크) 
- 정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크. 이미지, 비디오 등을 캐시 가능 

**고려사항**
- 자주 사용되지 않는 콘텐츠는 CDN에서 빼기 (비용 문제)
- 적절한 만료 시한 설정
- CDN 장애에 대한 대처 방안 고려
- 콘텐츠 무효화 방법을 통해 필요없는 데이터 제거 

-> 정적 콘텐츠는 CDN을 통해 더 나은 성능 보장

## 무상태 웹 계층
- 상태 정보를 RDS, NoSQL등과 같은 지속적 데이터 보관소에 저장. 이를 통해 단순하고 안정적이며 규모 확장이 쉽도록 설계
## 데이터 센터 
- 장애 발생시 다중 AZ 혹은 다중 Region을 등을 통한 다중 데이터센터 아키텍처 설계
- 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법 탐구 (ex. GeoDNS)
- 데이터 동기화: 트레픽 우회가 발생해도 여러 데이터센터에 걸쳐 다중화함으로서 데이터 실종을 막음
- 테스트와 배포: 자동화된 배포 도구를 통한 모든 데이터 센터에 동일한 서비스 제공

-> 시스템을 더 큰 규모로 확장하기 위해 시스템의 컴포넌트를 분리하여 각기 독립적으로 확장할 수 있어야.

## 메세지 큐
- 무손실을 보장하는 비동기 통신 지원 컴포넌트
- 생산자, 소비자 구조. 규모 확장성을 보장해야하는 안정적 애플리케이션에서 구성하기 좋음

## 로그, 메트릭, 자동화
- 로그: 에러 로그 모니터링을 통해 시스템의 오류와 문제를 찾을 수 있음
- 메트릭: 메트릭을 잘 수집하면 시스템의 현제 상태를 손쉽게 파악
    - 호스트 단위 메트릭: CPU, 메모리, 디스크I/O 등
    - 종합 메트릭: DB 계층 성능, 캐시 계층 성능 등
    - 비지니스 메트릭: 일별 능동 사용자, 수익, 재방문 등
- 자동화: 생산성을 높이기 위한 자동화 도구 활용

## 데이터베이스 규모 확장
- 수직적 규모 확장 / 수평적 규모 확장
- 수직적 확장(Scale-up): 기존 서버에 더 많은, 또는 고성능의 자원을 증설 
- 수평적 확장(Sharding): 대규모 데이터베이스를 샤드 라고 부르는 작은 단위로 분할. 샤딩 키를 지정을 통한 데이터베이스 분산

[샤딩 도입을 통해 새로운 문제]
- 재샤딩: 샤드 부족/샤드가 데이터 분포가 비균등 (샤드 소진)시 샤드 키를 계산하는 함수 변경 및 데이터 재배치 => 안정해시 기법
- 유명인사 문제(핫스팟 키 문제): 특정 샤드에 질의가 집중되어 과부화. 유명인사 각각애 샤드를 할당 혹은 쪼갬으로서 해결
- 조인과 비정규화: 쉬운 조인을 위해 데이터베이스를 비정규화

## 백만 사용자, 그 이상 - 시스템 규모 확장을 튀해 살펴본 기법들
- 웹 계층은 무상태 계층으로  
- 모든 계층에 다중화 도입  
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

# 2장 개략적인 규모 추정
2장 키워드: `개략적 규모 추정을 효과적으로 하기 위한 규모 확장성 표현의 기초`

## 응답지연 값 - 모든 프로그래머의 기초
| 연산명           | 시간       |
|:------------------|:------------|
| L1 캐시 참조     | 0.5ns      |
| 분기 예측 오류(branch mispredict) | 5ns       |
| L2 캐시 참조     | 7ns        |
| 뮤텍스(mutex) 잠금/언락 | 100ns      |
| 주 메모리 참조    | 100ns      |
| Zippy로 1 KB 압축  | 10,000ns = 10μs |
| 1 Gbps 네트워크로 2 KB 전송 | 20,000ns = 20μs |
| 메모리에서 1 MB 순차적으로 read | 250,000ns = 250μs |
| 같은 데이터 센터 내에서의 메시지 왕복 지연시간 | 500,000ns = 500μs |
| 디스크 탐색(seek)  | 10,000,000ns = 10ms |
| 네트워크에서 1 MB 순차적으로 read | 10,000,000ns = 10ms |
| 디스크에서 1 MB 순차적으로 read | 30,000,000ns = 30ms |
| 한 패킷의 CA(캘리포니아)부터 네덜란드까지의 왕복 지연시간 | 150,000,000ns = 150ms |

ns = nanosecond(나노초), μs = microsecond(마이크로초), ms = millisecond(밀리초)  
1나노초 = 10^-9초  
1마이크로초 = 10^-6초 = 1,000나노초  
1밀리초 = 10^-3초 = 1,000μs = 1,000,000ns  

**수치 분석 결과**
- 메모리는 빠르지만 디스크는 아직 느리다
- 디스크 탐색(seek)은 가능하면 피하라
- 단순한 압축은 빠르다
- 데이터 전송전에 가능하면 압축해라
- 데이터 센터는 여러 리전에 분산되어 있으며, 이들 간 데이터를 주고받는 데는 시간이 걸린다

## 가용성 수치
9의 개수와 시스템 장애 시간 사이의 관계
|가용률|하루당 장애시간|주당 장애시간|개월당 장애시간|연간 장애시간|
|:---|:---|:---|:---|:---|
|99%|14.4분|1.68시간|7.31시간|3.56일|
|99.9%|1.44분|10.08분|43.83분|8.77시간|
|99.99%|8.64초|1.01분|4.38분|52.6분|
|99.999%|864밀리초|6.05초|26.3초|5.26분|
|99.9999%|86.4밀리초|604.8밀리초|2.63초|31.65초|

## 팁
- 근사치를 활용한 계산: ex. 99987 / 9.1 => 100,000 / 10
- 가정을 나중에 살펴보기 위해 따로 적어두라
- 단위를 붙여서 계산하라
- QPS, 최대 OPS, 저장소 요구량, 캐시 요구량, 서버 수등 문제가 많이 출제된다

# 3장 시스템 설계 면접 공략법
## 효과적 면접을 위한 4단계 접근법
1. 문제 이해 및 설계 범위 확정 
- 바로 답부터 제시하지 말 것. 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 할 것 (매우 중요한 단게)
2. 계략적 설계안 제시 및 동의 구하기 
- 면접관과 협력하며 진행할 것
3. 상세 설계
- 설계 대상 컴포턴트 사이의 우선순위를 정할 것. **똑같은 면접은 없다**
4. 마무리
- 설계 결과물과 관련된 후속 질문 혹은 추가 논의를 진핼할 것

**해야 할 것**
- 질문을 통해 확인. 자신의 가정은 틀릴 수 있다.
- 문제 요구사항 이해하기
- 면접관이 나의 사고흐름을 이해하도록 면접관과의 소통
- 가능하면 여러 해법 제시
- 개략적 설계에 면접관이 동의하면, 컴포넌트의 세부사항 설명하기. 가장 중요한 컴포넌트부터 할 것.
- 면접관의 아이디어 이끌어 내기
- 포기하지 말기

**하지 말아야 할 것**
- 전형적인 문제는 반드시 대비하기
- 요구사항이나 가정을 분명하게 하지 않고 설계를 제시 하지 말것
- 처음부터 특정 컴포넌트를 너무 깊이 설명하지 말기
- 진행 중 막히면, 힌트를 청할 것
- 소통에 주저하지 말기
- 설계안을 내놓는 순간 면접이 끝난것이 아니다. 의견을 일찍, 자주 구해라

**시간 배분(45분 기준으로)**
- 문제 이해 및 설계 범위 확정 (3~10분)
- 개략적 설계안 제시 및 동의 구하기 (10~15분)
- 상세 설계 (10~25분)
- 마무리 (3~5분)