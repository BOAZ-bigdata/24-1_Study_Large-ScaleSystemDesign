# 단일서버
모든 [컴포넌트](https://hanamon.kr/컴포넌트-component란/)가 단 한대의 서버에서 실행되는 간단한 시스템
- 컴포넌트란 프로그래밍을 함에 있어서 독립적으로 사용 가능한 각각의 독립된 모듈을 의미
![단일 서버](https://velog.velcdn.com/images/haron/post/53e5053d-37de-4a25-af77-6b8db685d152/image.png)

1. 사용자는 [DNS](https://www.ibm.com/kr-ko/topics/dns)(Domain Name Service)에 IP 주소를 질의하고 반환받는다. 
2. 반환된 IP 주소는 위 그림의 웹서버 주소이다.
3. 해당 IP 주소로 HTTP(HyperText Transfer Protocol)요청이 전달된다.
4. 요청을 받은 웹서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

# 데이터 베이스
서비스 사용자가 늘면 단일 서버로는 충분하지 않아 여러 서버를 둠
1. 웹 모바일 트래픽 처리 서버(웹계층)
2. 데이터 베이스 서버(데이터 계층)
이렇게 서버를 분할할 경우 그 각각을 **독립적으로 확장 가능**
![서버 분할](https://velog.velcdn.com/images/haron/post/354009d0-6fb1-4ced-8653-3c40ebb0313b/image.png)
## 어떤 데이터 베이스를 사용할 것 인가.
1. RDBMS(관계형 DB)
	자료를 테이블과 열,  칼럼으로 표현할 수 있고 각 테이블이 스키마로 정의 됨.
2. Nosql(비-관계형DB)
	 Hbase, Cassandra, DynamoDB 등 비정형 데이터에 적합한 DB로 4가지로 분류됨.
	 - 키-값 저장소(key-value store)
	 - 그래프 저장소(graph store)
	 - 칼럼 저장소(column store)
	 - 문서 저장소(document store)
	 또한 아래와 같은 경우에는 비-관계형 데이터 베이스가 적합
	 - **아주 낮은 응답 지연시간**(latency)이 요구됨
	 - **다루는 데이터가 비정형**이라 관계형 데이터가 아님
	 - 데이터(스키마리스 데이터) 등을 직렬화하거나 **역직렬화할 수 있기만 하면 됨**
		 - [직렬화](https://hub1234.tistory.com/26)란?
			 메모리를 디스크에 저장하거나 네트워크 통신에 사용하기 위한 형식으로 변환하는 것을 말한다.
			 Reference Type -> Value Type으로 변환
	 - 아주 **많은 양의 데이터를 저장**할 필요가 있음.

# 수직적 규모 확장 vs 수평적 규모 확장

### scale up
	서버에 고사양 자원을 추가하는 행위(더 좋은 CPU 더 많은 RAM)
### scale out
	더 많은 서버를 추가하여 성능을 개선하는 행위

### 수직적 구묘 확장 scale up의 한계
- 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없음
- 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않는다. 
- 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다. 

바로 위의 설계에서는 사용자가 웹 서버에 바로 연결된다.
- 즉, 웹서버가 다운되면 웹사이트가 터짐
- 또한 트레픽 중가에 대응할 수 없음.

## 로드밸런서
로드 밸런서는 부하 분산이라는 뜻으로 **웺서버에게 트래픽을 고르게 분산하는 역할**을 한다.
![로드밸런서](https://velog.velcdn.com/images/haron/post/2ad128e8-8a85-4a08-ab8e-f727341efe56/image.png)
사용자는 로드 밸런서의 공개 IP로 접속하고 서버간 통신에는 사설 IP 주소를 이용하여 **보안성을 보장**한다.

위 그림처럼 웹서버를 하나 더 추가할 경우 기대되는 효과
- 서버 1이 다운되면 모든 트레픽은 서버2로 전송된다. -> **사이트** **전체가 다운되는 것을 방지**
- 트래픽이 가파르게 증가하면 웹서버 계층에 단순히 많은 서버를 추가하면 됨. -> 로드 밸런서가 **자동으로 트래픽을 분산.**

## 데이터 베이스 다중화
서버 사이에 주(master)- 부(slave)관계를 설정하고 데이터 원본은 주 서버에 사본은 부 서버에 저장하는 방식.
- 쓰기연산(insert, delete, update) 등은 마스터에만 지원하고 slave에는 읽기연산을 지원한다.
- 통상적으로 읽기 연산의 비중이 쓰기 연산의 비중보다 훨씬 높다. 즉, 부DB가 더 많음.
![데이터 베이스 다중화](https://velog.velcdn.com/images/haron/post/b898971e-ecfb-4316-bcfd-a30f547ea737/image.png)

위와 같이 데이터 베이스를 다중화할 경우의 이득
- 더 나은 성능: 읽기 연산이 분산되기에 병렬로 처리될 수 있는 질의(query)의 수가 늘어나므로, 성능이 좋아진다.
- **안전성**: 데이터 베이스 서버 가운데 일부가 파괴되어도 **데이터는 보존**됨.
- **가용성**: 하나의 데이터 베이스에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있음.

위와 같은 설계의 경우.
- 부 서버가 한대 뿐은데 다운된 경우,  읽기 연산이 하니적으로 모두 주 서비스로 전달 또한 즉시,  새로운 부 서버가 장애 서버를 대체
- 주DB 서버가 다운될 경우 부DB 서버가 대체
- 물론 프로덕션 환경의 경우 훨씬 복잡함. **부 서버에 보관된 데이터가 최신 데이터가 아닐 수 있음**. -> 복구 스크립트 가동 or 다중마스터 및 원형 다중화 방식을 도입

## 로드밸런서 & 데이터 베이스 다중화
![설계안](https://github.com/StatisticsFox/Blog/assets/92065443/b3a64bbb-6569-47c9-91ef-4a066ff2456c)

이 설계안이 동작하는 과정
- 사용자는 DNS로 부터 로드밸런서의 공개 아이피 주소를 받는다. 
- 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
- HTTP 요청이 서버1이나 서버2로 전송된다.
- 웹 서버는 사용자의 데이터를 부 데이터베이스에서 읽는다.
- 웹 서버는 데이터 변경 연산을 주 데이터 베이스로 전달한다. 데이터 추가, 삭제, 갱신 연산이 이에 해당한다.

# 캐시
응답시간(Latency)라고 하는데 이를 개선하기 위해서는 캐시를 붙이고 정적 콘텐츠를 콘텐츠 전송 네트워크CDN에 옮기면 해결할 수 있다.

캐시란?
- 값비싼 연산결과 또는 자주 참고되는 데이터를 메모리 안에 두고 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소다.
- 애플리케이션의 성능은 데이터 베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.

## 캐시 계층
캐시 계층이란 데이터가 잠시 보관되는 곳으로 데이터 베이스보다 훨씬 빠르다.
![캐시계층](https://velog.velcdn.com/images/haron/post/c7afec8b-27e2-462f-bee1-b95951b543be/image.png)

### 주도형 캐시 전략
- 요청을 받은 웹서버는 캐시에서 먼저 응답이 저장되어 있는지 확인하고 없는 경우 데이터 베이스에서 데이터를 가져와 캐시에 저장한뒤 반환한다.

## 캐시 사용 시 유의할 점
- 데이터 갱신은 자주 일어나지 않으나 참조가 빈번하게 일어난다면 고려해볼만 하다.
- 캐시는 데이터를 휘발성 메모리에 두기 때문에 영속적으로 보관할 중요한 데이터는 지속적 저장소에 두어야 한다.
- 캐시에 보관된 데이터는 어떻게 만료할 것인지 정책을 마련해두는 것도 좋은 습관이다.
	- 너무 짧을 경우 데이터 베이스를 너무 자주 읽으며 너무 길다면 원본과 차이가 나기 때문에 곤란하다.
- 일관성은 데이터 저장소이 원본과 캐시 내 사본이 같은지 여부이다. 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리되지 않는 경우 일어날 수 있다. -> 참고 논문 \<Scaling Memcache at Facebook\>
- 캐시서버를 한 대만 두는 경우 해당 서버는 단일 장애지점(SPOF)가 되어 버릴 가능성이 있어 여러지역에 걸쳐 캐시 서버를 분산 시켜야 한다. 
	- SPOF: "어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜 버릴 수 있는 경우"
	-사진
- 캐시 메모리를 크게 잡아야 한다. 캐시 메모리가 너무 작으면 엑세스 패턴에 따라서는 성능 저하로 이어지기에 과할당하는 것디 좋다.
- 데이터 방출 정책을 정하자
	- LRU: 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 정책
	- LFU: 사용빈도가 가장 낮은 데이터를 내보내는 정책
	- FIFO: 가장 먼저 캐시된 데이터를 가장 먼저 내보내는 정책

# 콘텐츠 전송 네트워크(CDN)
CDN이란?
- 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, JS 등을 캐시할 수 있다.
다음은 CDN이 어떻게 동작하는지 설명한다.
![CDN 동작방식](https://github.com/StatisticsFox/Blog/assets/92065443/8ca4b288-f2c3-4fd0-b12e-bf91843bd7ee)
1. 사용자 A가 URL을 통해 image.png에 접슨한다. URL 도메인은 CDN서비스 사용자가 제공한 것이다. 
2. CDN 서버의 캐시에 해당 이미지다 없는 경우 원본 서버(웹 서버 or S3 등)에 요청하여 파일을 가져온다.
3. 원본 서버가 파일을 CDN서버에 반환한다. 응답의 HTTP해더는 해당 파일의 수명기간(TTL)을 설정한다.
4. CDN서버는 파일을 캐시하고 사용자 A에게 반환한다. 이미지는 TTL기간까지 캐시 서버에 남아있다.
5. 사용자 B가 같은 이미지에 대한 요청을 CDN에게 요청한다.
6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.

## CDN 사용시 고려해야할 상황
1. 비용
	- CDN은 보통 써드 파티에 의해 운영되며 데이터 전송 양에 따라 요금을 내게된다. 자주 사용하지 않은 콘텐츠를 캐싱하는 것은 이득이 적기에 CDN에서 빼야 한다.
2. 적절한 만료시한 설정 
	- 시의성이 중요한 콘텐츠일 경우 너무 길지도 않고 짧지도 않게 잘 설정해야 한다.
3. CDN 장애에 대한 대처 방안 
	- CDN 자체가 죽어벼렸을 경우 웹싸이트나 애플리케이션이 어떨게 동작해야 하는지 고려해야 한다. CDN이 응답하지 않을 경우 바로 감지하여 원본 서버에서 가죠올수 있도록 클라이언트를 구성해야 한다.
4. 콘텐츠 무효화 방법: 아직 만료되지 않은 컨텐츠라도 아래 방법으로 CDN에서 제거 가능
	- CDN 사업자가 제공하는 API를 사용하여 제거
	- 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용 URL 마지막 버전에 번호를 인자로 지정 예. image.png?v=2

CDN과 캐시가 추가된 시스템 설계도
![KakaoTalk_Image_2024-01-30-02-38-48](https://github.com/StatisticsFox/Blog/assets/92065443/a901d00c-f8b9-4bdc-a76f-04ce168491e3)

즉, 정리하면 다음과 같다.
1. 정적 콘텐츠(JS, CSS, 이미지 등)는 더 이상 웹 서버를 통해 서비스 하지 않으며, CDN을 통해 더 나은 성능을 보장한다.
2. 캐시가 데이터 베이스의 부하를 줄여준다.

# 무상태(stateless)웹 계층
이제 웹 계층을 수평적으로 확장하는 방법을 고민해보자
상태 정보를 웹계틍에서 제거하고 관계형 DB나 Nosql과 같은 지속성 저장소에 보관하는 것이 바람직하다.

## 상태 정보 의존적인 아키텍처
![상태 정보 의존적인 아키텍쳐](https://velog.velcdn.com/images/mmy789/post/c8839423-f009-4a96-b12d-64805936be17/image.png)
## 무상태 아키텍처
![무상태](https://velog.velcdn.com/images/mmy789/post/9cca2d9a-0f21-4105-ac94-a997844052a0/image.png)
위 처럼 상태 정보가 웹서버로 부터 물리적으로 분리되어 있다. 
이런 구조는 단순하고 안정적이며 규모확장이 쉽다.

아래는 무상태 웹계층을 갖도록 변경한 기존 설계다.
![](https://velog.velcdn.com/images/mmy789/post/75b776ba-b0fe-45c4-8467-026053b9f60c/image.png)


> **세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장**하도록 만들었다.
- 세션 데이터를 NoSQL에 담은 이유는 규모확장이 간편해서다.  이 공유 저장소는 관계형DB일수도 Redis와 같은 캐시 시스템일 수도 있다.
- 1 자동 규모 확장은 상태 정보가 웹 서버들로부터 제거되었으므로, **트래픽 양에 따라 웹 서버를 넣거나 빼기**만 하면 **자동으로 규모를 확장**할 수 있게 되었다.

# 데이터 센터
> **가용성을 높이고 전 세계 어디서도 쾌적하게 사용**할 수 있도록 하기 위해서는 **여러 데이터 센터를 지원**하는 것이 필수다.

**장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데**, 보통 이 절차를 **지리적 라우팅**(geoDNS-routing 또는 geo-routing)이라고 부른다. 지리적 라우팅에서의 geoDNS는 **사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해 주는 DNS 서비스**다.

아래 그림에서, `x%` 사용자는 `US-East 센터`로, 그리고 `(100 - x)%`의 사용자는 `US-West 센터`로 안내된다.
![](https://velog.velcdn.com/images/mmy789/post/834f5978-185d-4dfe-9b86-16992bab725b/image.png)

이들 데이터 센터 중 **하나에 심각한 장애가 발생**하면 **모든 트래픽은 장애가 없는 데이터 센터로 전송된다.** 아래 그림은 `데이터센터2(US-West)`에 장애가 발생했을 때, 모든 트래픽이 `데이터센터1(US-East)`로 전송되는 상황이다.

![](https://velog.velcdn.com/images/mmy789/post/624faf3c-1d4c-4e8c-955f-96932dc7ba09/image.png)

이 사례와 같은 다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.

#### 1. 트래픽 우회

- **올바른 데이터 센터로 트래픽을 보내는 효과적인 방법**을 찾아야 한다.
- `GeoDNS`는 사용자에게서 가장 가까운 데이터센터로 트래픽을 보낼 수 있도록 해 준다.  
    

#### 2. 데이터 동기화(synchronization)

- 데이터 센터마다 별도의 데이터베이스를 사용하고 있는 상황이라면, 장애가 자동으로 복구되어(failover) 트래픽이 다른 데이터베이스로 우회된다 해도, **해당 데이터센터에는 찾는 데이터가 없을 수 있다.** 
- 이런 상황을 막는 보편적 전략은 **데이터를 여러 데이터센터에 걸쳐 다중화하는 것**이다. (Netflix)

#### 3. 테스트와 배포(deployment)

- 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트해보는 것이 중요하다. 
- 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 한다.

# 메시지 큐
> 시스템을 더 큰 규모로 확장하기 위해서는 **시스템의 컴포넌트를 분리**하여, **각기 독립적으로 확장**될 수 있도록 해야 한다. **메시지 큐(message queue)**는 많은 실제 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심적 전략 가운데 하나다.

>메시지 큐는 메시지의 **무손실(durability, 즉 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트**이다. **메시지의 버퍼 역할**을 하며, **비동기적으로 전송**한다.

### 메시지 큐의 기본 아키텍처
- **생산자(or 발행자)** 라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행한다.
- 큐에는 보통 **소비자(or 구독자)**라고 불리는 **서비스 혹은 서버가 연결**되어 있는데, **메시지를 받아 그에 맞는 동작을 수행**한다.

![](https://velog.velcdn.com/images/haron/post/a459526f-7ec2-48d1-9aec-f7dc2be73278/image.png)

### 메시지 큐 사용 목적

- 메시지 큐를 이용하면 **서비스 또는 서버 간 결합이 느슨**해져서, **규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.** 
- **생산자**는 **소비자 프로세스가 다운되어 있어도 메시지를 발행**할 수 있고,  
    **소비자**는 **생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신**할 수 있다.

# 로그, 메트릭 그리고 자동화
비지니스의 규모가 커지면 **로그, 매트릭, 자동화 도구**에 필수적으로 투자해야한다.

그럼 이런 도구들은 뭘까?

- 로그: 에러 로그 모니터링은 굉장히 중요 한데 이를 위해. **로그를 단일 서비스로 모아주는 도구를 사용**
- 메트릭: 메트릭을 잘 수집하면 사업 현황에 유용한 정보를 얻거나 **시스템의 현재 상태를 손쉽게 파악**가능
	- 호스트 단위 메트릭: 하드웹어에 관한 메트릭
	- 종합 메트릭: DB나 캐시 계층 성능 메트릭
	- 핵심 비즈니스 메트릭: 수익, 재방문, 일별 능동 사용자 메트릭 등
- 자동화: 생산성과 안정성을 높이기 위해 사용 하며 보통 **CI/CD 등을 도화주는 도구를 활용**

### 메시지 큐 로그 메트릭 자동화를 반영한 설계안
![](https://velog.velcdn.com/images/iln1027/post/dff08c78-adc1-40b2-b938-ddb7ee9ee783/image.png)

# 데이터 베이스의 규모 확장
저장할 데이터가 많아지면 데이터베이스를 확장해야 하는데 두가지 방안이 존재한다.

## 수직적 확장
고성능의 자원을 증설하는 방법으로 단 한대의 마스터 DB로 처리하게 되는 경우다. 
- stackoverflow가 단 한대의 단 한대의 마스터 데이터 베이스로 천만명의 사용자를 처리
단 이럴경우 심각한 단점이 존재한다.

- 자원 증설에 한계가 있어 **사용자가 늘어나면 결국 감당하기 어렵게 된다.**
- 단일 장애 지점으로 인한 위험성이 크다.(SPOF)
- 고성능 서버로 올라갈 수 록 **가격이 올라 비용이 많이 든다.**

## 수평적확장
데이터 베이스의 수평적 확장은 **샤딩**이라고 하며 더 많은 서버를 추가함으로써 성능을 향상 시킬 수 있다.

샤딩은 샤드라고 부르는 작은 단위로 분할하는 기술로, 모든 샤드는 같은 스키마를 사용하지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

![](https://velog.velcdn.com/images/iln1027/post/3593052b-9b7d-4e8b-9c83-53ad291b4b4d/image.png)

### 샤딩 전략 구현시 고려사항
가장 중요한 것은 샤딩키를 어떻게 정하느냐 하는 것이다. 파티션 키라고도 부르며, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다. 

위 그림에서 샤딩키는 user_id 이다. 

샤딩은 데이터베이스 규모 확장을 실현하는 좋은 기술이지만 완벽하지는 않기 때문애 아래와 같은 문제가 발생 할 수 있다.

#### 데이터의 재샤딩
1. 데이터가 너무 많아져서 **하나의 샤드로는 더이상 감당하기 어려울 때**
2. 샤드간 데이터의 분포가 균드하지 못해 한 샤드가 다른 사드에 비해 **샤드 소진 현상이 빨라질때**

위와 같은 현상이 발생하면 샤드 키를 지정하는 함수를 변경하고 데이터를 재배치 해야 한다.
- 안정 해시 기법 사용 5장에서 다룰 예정
#### 유명인사 문제
핫스팟 키라고도 부르며 특정 샤드에 질의가 집중되어 서버 과부하가 걸리는 문제
이 문제를 풀려면 샤드를 더 잘개 쪼개던지 해야 함.
#### 조인과 비정규화
샤딩을 하면 결국 데이터 베이스를 쪼개기 때문에 join이 힘들어진다. 데이터베니스를 비정규화 하여 하나의 테이블에서 쿼리가 수행될 수 있도록 하는 것.


#### 데이터 베니스 샤딩을이용한 설계안
![](https://velog.velcdn.com/images/iln1027/post/4ae24928-5fa7-42c6-ae80-7d62649a989b/image.png)

# 백만 사용자 그 이상
제목 그대로 그 이상을 바라보기 위해 지금까지 배운 내용을 적용하면 된다.

- 웹 계층은 무상태 계층으로
- ﻿﻿모든 계층에 다중화 도입
- ﻿﻿가능한 한 많은 데이터를 캐시할 것
- ﻿﻿여러 데이터 센터를 지원할 것
- ﻿﻿정적 콘텐츠는 CDN을 통해 서비스할 것
- ﻿﻿데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- ﻿﻿각 계층은 독립적 서비스로 분할할 것
- ﻿﻿시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것