# 12장~13장

- [12장~13장](#12장13장)
- [12장 채팅 시스템 설계](#12장-채팅-시스템-설계)
  - [포인트 파악하기](#포인트-파악하기)
  - [개략적 설계안 제시](#개략적-설계안-제시)
    - [데이터 저장소](#데이터-저장소)
    - [메시지 ID](#메시지-id)
    - [클라이언트 연결을 위한 적합한 서버 탐색](#클라이언트-연결을-위한-적합한-서버-탐색)
    - [여러 단말 사이의 메시지 동기화](#여러-단말-사이의-메시지-동기화)
    - [사용자 온라인 여부 구현](#사용자-온라인-여부-구현)
    - [사용자의 친구에게 온라인/오프라인 상태 변경 정보 전달](#사용자의-친구에게-온라인오프라인-상태-변경-정보-전달)
    - [추가 고려사항](#추가-고려사항)
- [13장 검색어 자동완성 시스템](#13장-검색어-자동완성-시스템)
  - [요구사항](#요구사항)
  - [개략적 설계안 제시](#개략적-설계안-제시-1)
    - [트라이 자료구조](#트라이-자료구조)
    - [검색어 삭제](#검색어-삭제)

# 12장 채팅 시스템 설계

채팅 시스템 설계법에 대한 이야기

- **한 채팅방에 들어가는 인원 수, 응답 지연 등 요구사항에 따라 설계가 달라짐**

## 포인트 파악하기

개략적으로 설계해보면 다음과 같이 기능이 나뉨

- `클라이언트들로부터 메시지 수신`
- `메시지 수신자 결정 및 전달`
- `수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관`

메시지 송수신 방식에 대한 고민도 필요함

- `폴링`
  - 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법
- `롱 폴링`
  - 폴링은 짧은 자주 호출할 수록 비용이 늘어나므로 타임아웃을 길게두고 폴링해서 비용을 줄이는 방법
  - 하지만 이것도 비효율적임
- `웹소켓`
  - 웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
  - http와 달리 stateful한 통신 방식임
  - 양방향 메시지 전송이 가능하므로 채팅에 적합함
  - **단, 서버 측에서 소켓 연결 관리를 효율적으로 해야하는 어려움이 있음**

## 개략적 설계안 제시

채팅 시스템은 크게 세 부분으로 나누어 볼 수 있음

- `무상태(state-less) 서비스`
  - 상태를 들고 있지 않아도 되는 API
- `상태유지(stateful) 서비스`
  - 상태 유지가 필요한 소켓 API 등
  - 적합한 서버로 클라이언트를 연결시켜주기 위해 서비스 탐색(service discovery) 서비스가 필요함
- `서드파티 서비스`
  - 푸시 알림 전송 등

`규모 확장성`도 고려해야함

- 서버 한 대에 얼마나 많은 동시 접속이 가능할지 계산해보면
  - 동접자 1M, 접속당 10K의 서버 메모리 → 10GB 필요..
  - 하지만 10GB는 매우 비싼 비용. 따라서 로드밸런싱해야 함
  - 로드밸런싱해서 SPOF도 방지할 수 있음

### 데이터 저장소

**채팅은 데이터 양이 많으므로 데이터베이스 확장이 중요함**

`데이터 별로 살펴보자`

**사용자 정보, 설정, 친구 목록과 같은 일반적인 데이터**

- 안정성 보장을 위해 `RDBMS`
- 다중화, 샤딩 고려 필요

**채팅 이력 데이터**

- 데이터 양이 엄청 많으므로 읽기/쓰기 연산 패턴을 잘 이해해서 골라야함
- 페이스북 메신저나 왓츠앱은 매일 60B개의 메시지를 처리한다고 함..
  - 저자는 `키밸류(key-value) 저장소`를 추천
    - 키밸류 저장소는 수평적 규모확장이 쉽고 레이턴시가 낮음
    - RDBMS는 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어나는 이유도 있고
    - 이미 많은 안정적인 채팅 시스템이 키밸류 저장소를 채택하고 있다고 함
    - 페이스북 메신저는 HBase, 디스코드는 카산드라(Cassandra)

### 메시지 ID

**message_id는 다음과 같은 속성을 만족해야 함**

- 고유해야함(unique)
- 정렬 가능해야 하며 시간 순서와 일치해야 함

**위 두 조건을 만족시키기 위해서 NoSQL에서는** `snowflake`**와 같은 유일 ID 생성기를 사용해볼 수 있음**

### 클라이언트 연결을 위한 적합한 서버 탐색

- 적합한 서버로 클라이언트를 연결시켜주기 위해 `서비스 탐색`(service discovery)이 필요함
- **지역적으로 가까운 서버**, **서버의 용량 등이 적합한 서버를 판단하는 기준**
- **e.g. 아파치 주키퍼(Apache Zookeeper)**

### 여러 단말 사이의 메시지 동기화

여러 단말기를 사용한다면 메시지 동기화도 중요함

`cur_max_message_id`라는 기준 값을 두어서 동기화 처리.

### 사용자 온라인 여부 구현

네트워크 순단이 발생할 수 있으므로 박동(heartbeat) 검사를 통해 사용자 활성 여부를 구현할 수 있음

e.g. 박동 이벤트를 30초 동안 수신하지 못했다면 오프라인 상태로 변경

### 사용자의 친구에게 온라인/오프라인 상태 변경 정보 전달

사용자의 친구에게 온라인/오프라인 상태 변경 정보를 전달하는 건 친구 수가 많을 때 매우 비효율적일 수 있음

이는 클라이언트가 정말 필요할 때 데이터를 읽게 하는 식으로 조정해서 트래픽을 제어해볼 수 있음

### 추가 고려사항

- `사진, 비디오 등의 미디어 지원`
  - 데이터의 크기가 커지므로 압축 방식, 클라우드 저장소, 섬네일 생성 등을 고려해볼 수 있음
- `종단 간 암호화`
  - 메시지를 암호화해서 해당 발신인과 수신인을 제외하면 아무도 해당 메시지를 볼 수 없도록 함
- `캐시`
  - 이미 많이 읽은 메시지를 클라이언트에 캐시해 두면 서버와 주고받는 데이터 양을 줄일 수 있음
- `로딩 속도 개선`
  - slack은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선함
- `오류 처리`
  - 고가용성
    - 서버 하나가 죽으면 서비스 디스커버리가 살아있는 새로운 서버를 배정하고 다시 접속할 수 있도록 고가용성을 보장해야함
  - 메시지 재전송
    - 재시도 로직이나 메시지 큐를 이용해서 안정적 전송을 보장

# 13장 검색어 자동완성 시스템

검색어 자동완성 시스템 설계법에 대한 이야기

## 요구사항

- 빠른 응답 속도
- 입력한 단어와의 연관성
- 자동완성 단어 정렬
  - 인기도 등 순위 모델 필요
- 규모 확장성
  - 많은 트래픽 대응 가능하도록 확장 가능해야함
- 고가용성

## 개략적 설계안 제시

개략적으로 설계해보면 `데이터 수집 서비스`와 `질의 서비스`로 나뉨

- `데이터 수집 서비스`
  - 사용자가 입력한 질의를 실시간으로 수집하는 서비스
  - 질의문과 사용빈도를 저장하는 빈도 테이블(frequency table)을 두기
- `질의 서비스`
  - 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스
  - 빈도 테이블에서 빈도 값 정렬로 가장 많이 사용된 5개 질의문 조회

### 트라이 자료구조

트라이 자료구조를 이용해 질의 서비스를 최적화하기

- `트라이` 자료구조
  - `접두어 트리`라고도 함
  - 접두어 별로 빈도 수를 저장하는 트리 구조
- `더 최적화하기`
  - **접두어의 최대 길이를 제한**
    - 탐색 범위가 줄어듬
  - **각 노드에 인기 검색어를 캐시**
    - 각 노드에 K개의 인기 검색어를 저장해두면 전체 트라이를 검색하는 일을 방지할 수 있음
- `트라이 생성 최적화`
  - 트라이를 자주 생성하면 연산량이 많으므로 부하가 심해짐
  - 따라서 데이터를 어딘가에 모아두고 일정 주기를 지정해서 갱신하는 것도 방법임
  - 이 일정 주기는 실시간성 중요도에 따라 다름

### 검색어 삭제

- 혐오성이 짙거나, 폭력적이거나, 성적으로 노골적이거나, 여러가지로 위함한 질의어를 자동완성에서 제외해야함
- 이를 위해 필터 계층을 두어야 함 조회 시에 트라이 캐시 앞에 두는 것이 필터 수정에 있어서 자유도가 높음
  - 트라이를 수정하는 건 연산량이 많아서 별로일듯
  - (조회 시) API 서버 ← 필터 계층 ← 트라이 캐시
