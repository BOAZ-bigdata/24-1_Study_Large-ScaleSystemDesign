# 사용자 수에 따른 규모 확장성

## 1️⃣ 단일 서버

- 웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행
  
![CamScanner 2024-01-31 12 28(1)_1](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/e4b76f7e-1b94-47ca-ae68-5f2eb41dab8f)
- 사용자 요청 처리 흐름
    1. 도메인 이름을 이용하여 웹사이트에 접속
    2. DNS 조회 결과 IP 주소 반환
    3. 해당 IP 주소로 HTTP 요청 전달
    4. 요청 받은 웹 서버가 응답 반환
- 실제 요청이 들어오는 단말의 종류
    - 웹 어플리케이션
    - 모바일 앱

---

`❗️사용자 증가 → 웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)으로 분리`

## 2️⃣ 데이터베이스

- 데이터베이스 종류
    - 관계형 데이터베이스 : 자료를 테이블과 열, 칼럼으로 표현하는 SQL
    - 비-관계형 데이터베이스 : 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소와 같은 NoSQL
- 비-관계형 데이터베이스를 쓰는 경우
    - 아주 낮은 응답 지연시간(latency)
    - 비정형 데이터
    - 직렬화/역직렬화 가능한 데이터
    - 아주 많은 양의 데이터

---

## 3️⃣ 수직적 규모 확장 vs 수평적 규모 확장

- 수직적 규모 확장(scale up) : 서버에 고사양 자원을 추가
- 수평적 규모 확장(scale out) : 더 많은 서버를 추가

→ 수직적 규모 확장은 단순하기 때문에 트래픽 양이 적을 때는 좋지만,

→ 확장의 한계, 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안 없다는 문제

![CamScanner 2024-01-31 12 44(1)_1](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/cf9158c5-2579-4ff6-8959-8b8730180b4f)

`❗️웹 서버 다운 or 트래픽 증가 → 웹 서버들에게 트래픽 부하를 고르게 분산하는 로드밸런서`

### 웹 계층 : 로드밸런서

- 동작 방식
    - 사용자는 로드밸런서의 공개 IP주소로 접근
    - 로드밸런서는 사설 IP 주소를 이용하여 웹 서버와 통신
- 문제 해결
    - 장애 자동복구 해결 (no failover) : 한 서버 다운되면 다른 서버로 트래픽 전송
    - 가용성 향상(availability) : 웹 서버 계층에 서버 추가하면 자동적으로 로드밸런서가 트래픽 분산

`❗️데이터에 대한 장애 자동복구, 다중화 문제 → 주-데이터베이스와 부-데이터베이스 여러개로 데이터베이스 다중화` 

### 데이터 계층 : 데이터베이스 다중화

- 주 데이터베이스(마스터)
    - 데이터 원본 저장
    - 쓰기 연산
- 부 데이터베이스(슬레이브)
    - 데이터 사본 저장
    - 읽기 연산 (→ 쓰기 연산보다 자주 발생하므로 부 데이터베이스 수가 더 많음)
- 장점
    - 더 나은 성능 : 연산 분산 → 병렬로 처리될 수 있는 질의 수의 증가
    - 안정성 : 일부가 파괴되어도 데이터 보존
    - 가용성 : 하나에 장애 발생해도 다른 서버에서 가져옴
        - 부 데이터베이스가 한 대라면 새 서버의 대체 전까지 읽기 연산이 한시적으로 주 데이터베이스로 전달
        - 부 데이터베이스가 여러 대라면 새 서버의 대체 전까지 나머지 부 데이터베이스로 분산
        - 주 데이터베이스가 다운되었는데 부 데이터베이스가 한 대라면, 해당 부 데이터베이스가 주 데이터베이스가 된다

---

`❗️응답시간(latency)에 대한 개선 → "캐시"를 붙이고 정적 콘텐츠를 "CDN"으로 옮기기`

## 4️⃣ 캐시

- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 빨리 처리될 수 있도록 하는 저장소
- 캐시 계층 : 데이터가 잠시 보관되는 빠른 저장소
- 장점 → 성능 개선, 데이터 베이스 부하 감소, 캐시 계층 독립적 확장 가능
- 캐시 서버를 두는 방법 예시 : 읽기 주도형 캐시 전략
    - ![CamScanner 2024-01-31 12 44(1)_2](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/776566e2-51f5-402d-bcfd-9fc9177eca92)

### 캐시 사용 시 유의할 점

- 캐시는 어떤 상황에 바람직한가
- 어떤 데이터를 캐시에 두어야 하는가
- 캐시에 보관된 데이터는 어떻게 만료되는가
- 일관성은 어떻게 유지되는가
- 장애에는 어떻게 대처할 것인가
- 캐시 메모리는 얼마나 크게 잡을 것인가
- 데이터 방출 정책은 무엇인가

## 5️⃣ 콘텐츠 전송 네트워크(CDN)

- 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크 (이미지, 비디오, CSS, JavaScript)
- 사용자가 웹사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠 전달
    
    → 사용자와 CDN 서버의 거리에 따라 로드 속도 달라진다.
    
- CDN의 동작 과정
  ![CamScanner 2024-01-31 12 44(1)_3](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/a5850584-80a8-400e-a1ab-1cb1c31857ae)
    1. 사용자 A가 이미지 URL을 이용해 image.png에 접근 (URL 도메인은 CDN 서비스 사업자 제공)
    2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본 서버에 요청하여 파일 가져옴
    3. 원본 서버가 파일을 CDN 서버에 반환
    4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환
    5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송하면 캐시를 통해 처리

### CDN 사용 시 고려해야 할 사항

- 비용
- 적절한 만료 시한 설정
- CDN 장애에 대한 대처 방안
- 콘첸츠 무효화 방법

---

`❗️웹 계층에 대한 "수평적" 확장 → 상태 정보를 웹 계층에서 제거(무상태)` 

## 6️⃣ 무상태(stateless) 웹 계층

- 상태 정보를 관계형 데이터베이스나 NoSQL과 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록

### 상태 정보 의존적인 아키텍처

- 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다
- 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야한다는 문제

### 무상태 아키텍처
![CamScanner 2024-01-31 12 44(1)_4](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/043f13d6-4984-41c3-aec7-7b1b1cce1c82)

- 사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달 가능
- 상태 정보가 필요할 경우 공유 저장소로부터 데이터 가져옴 (상태 정보가 웹 서버로부터 물리적으로 분리)
    
    → 단순, 안정적, 규모 확장 쉬움
    
- 세션 데이터를 웹 계층에서 분리 → 지속성 데이터 보관소에 저장하도록
- 상태 정보의 제거 → 자동 규모 확장 가능 (트래픽 양에 따라 웹 서버를 자동으로 추가/삭제)

---

`❗️가용성 높이기 → 여러 데이터 센터` 

## 7️⃣ 데이터 센터

- 지리적 라우팅 : 도메인 이름을 사용자의 위치에서 가장 가까운 데이터 센터의 IP 주소로 변환
- 다중 데이터센터 아키텍처를 만들 때 고려할 기술적 난제
    - 트래픽 우회
    - 데이터 동기화
    - 테스트와 배포

---

`❗️더 큰 규모로 확장→ 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장`

## 8️⃣ 메세지 큐

- 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트
    
    ( 무손실 : 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)
    
- 기본 아키텍처
  ![CamScanner 2024-01-31 12 44(1)_5](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/36689434-4dd7-4bf3-b22e-1382a9f8be27)

    - 생산자/발행자 : 입력서비스로 메시지를 만들어 메시지 큐에 발행
    - 소비자/구독자 : 연결된 큐에서 메시지를 받아 동작 수행
- 장점
    - 서비스/서버 간 결합이 느슨 → 규모 확장성 용이
    - 생산자/소비자는 상대방이 다운되어있어도 발행/수신이 가능

---

`❗️사업 규모가 커지고 나면 필요해지는 것들` 

## 9️⃣ 로그, 메트릭 그리고 자동화

### 로그

- 에러 로그 모니터링 → 시스템의 오류와 문제들을 보다 쉽게 찾아낼 수 있도록
- 단일 서비스로 로그를 모아주는 도구 활용하면 편리

### 메트릭

- 사업 현황에 유용한 정보, 시스템의 현재 상태 손쉽게 파악 가능
- 종류
    - 호스트 단위 메트릭
    - 종합 메트릭
    - 핵심 비즈니스 메트릭

### 자동화

- 생산성 높이기 위해 CI 도와주는 것 같은 자동화 도구 활용 → 문제 쉽게 감지, 절차 자동화로 개발 생산성 향상

---

`❗️데이터 베이스의 규모 확장`

## 🔟 데이터베이스의 규모 확장
![CamScanner 2024-01-31 12 44(1)_6](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/f8ad385f-4d03-4a21-973c-26919a249b34)

### 수직정 확장

- 기존 서버에 더 많은 고성능 자원을 증설
- 문제
    - 하드웨어의 한계
    - SPOF(Single Point of Failure)로 인한 위험성
    - 비용

### 수평적 확장

- 더 많은 서버를 추가
- 샤딩(Sharding) : 대규모 데이터 베이스를 샤드라고 불리는 작은 단위로 분할. 모든 샤드는 같은 스키마, 중복 없는 데이터 저장
  ![CamScanner 2024-01-31 12 44(1)_7](https://github.com/NoMyeongEun/24-1_Study_Large-ScaleSystemDesign/assets/90135669/e5e7e1c0-c9f1-485b-b8cf-305f20f15f94)
- 샤딩 전략을 구현할 때 가장 중요한 것 : 샤딩 키의 정의
    - 샤딩 키(파티션 키) : 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성
        
        → 샤딩 키를 통해 데이터 조회/변경을 처리하여 효율 높일 수 있으므로, 데이터롤 고르게 분할 할 수 있는 샤딩 키를 정해야 한다.
        
- 샤딩을 도입할 때 풀어야 할 문제
    - 데이터의 재 샤딩 : 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때, 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때
    - 유명인사 문제(핫스팟 키 문제) : 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
    - 조인과 비정규화 : 여러 샤드에 걸친 데이터에 대해서 조인 어려움
